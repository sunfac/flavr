We must consider that the app needs to be intelligent, scalable, and habit-forming, while presenting users with a clear and minimal Discover / Plan / Capture framework.

Core Ethos

Discover – Users should explore appealing, chef/restaurant-inspired dishes aligned with their taste profile. It is essential that recipes do not repeat or feel regurgitated, and that when linked to a restaurant, mood, or chef persona, the suggestions feel authentic and consistent. Transparency should be built in so users understand why a dish is recommended.

Plan – Users must be able to generate clear weekly meal plans tailored to their preferences, with a shoppable list and easy access to daily recipes. This requires consolidating existing tools into one simple flow while maintaining a clean, minimalist UI. Plans should encourage a habit loop of plan → shop → cook → review, with nudges, streaks, and progress tracking.

Capture – The current photo-to-recipe feature is strong and should remain as-is, but integrated into the same learning loop to refine the user’s taste profile.

Scalability & Technical Considerations

Supersede unused or legacy code — while 8 modes exist in code, only 4 are visible in the UI. We need to confirm which features are live vs. dormant, and remove redundant code paths to simplify the stack.

Standardize on OpenAI for AI generation to reduce complexity. Architect the system with a unified AI adapter layer so that model swaps or additions (e.g. future Gemini or Anthropic integration) can be supported without major refactors.

Ensure scalability by introducing background job queues (e.g. BullMQ) for AI generation, Redis for caching/session persistence, and template-first AI generation to cut costs and prevent timeouts.

Analytics, logging, and monitoring must be added for user behavior insights, funnel optimization, and system reliability.

User Experience & Onboarding

Consolidate chat interfaces into a single adaptive assistant.

Unify onboarding so that preferences seed Discover, Plan, and Capture modes simultaneously.

Reduce navigation overload by showing only the 3 core pillars.

Documentation Update
We must update the product documentation to clearly capture:

Which code modules are live vs. legacy/unused

Which features are visible in the UI today

Backend stack details: caching, databases, cost tracking, AI usage patterns (OpenAI only)

User learning logic: how taste profiles are created and updated

Subscription gating, pricing tiers, quotas, and upgrade flows

Scalability strategy: queues, caching, rate limiting, and template-first generation